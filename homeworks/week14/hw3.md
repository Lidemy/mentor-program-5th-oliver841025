## 什麼是 DNS？Google 有提供的公開的 DNS，對 Google 的好處以及對一般大眾的好處是什麼？

關於 DNS（Domain Name System(或 Service)），網域名稱系統
基本上，網際網路上的所有電腦，從智慧型手機或筆電到為大型零售網站提供內容的伺服器，都是使用數字找到彼此並互相通訊，而這些數字就稱為 **IP 位址**。當我們開啟 web 瀏覽器進入網站時，不需要記住這些冗長的數字進行輸入，而是輸入像是 amazon.com 或 google.com 這樣的**網域名稱**就可以連接到正確位置。

DNS 就是可以將網域名稱轉換成 IP 位址的一套系統軟體（服務），提供電腦彼此間連接。DNS 的作用就是「讓有意義的，人類較容易記憶的主機名稱(英文字母)，轉譯成為電腦所熟悉的 IP 位址！」，我們人類是記不起來這麼多數字的啦！

<!-- 你說你要去中正紀念堂，我 DNS 大人就告訴你在台北市中正區中山南路21號 -->

Google 提供的 DNS：

對 Google 來說：

- 簡單說 google 可以透過搜尋引擎來搜集大數據，分析後，以利他們做廣告投放或追蹤等商業目的，主要也是因為 google 搜尋引擎頻繁大量的抓取很多 DNS 的資訊，才可以將這些資料快取，所以才常常有被竊聽的感覺（？

對使用者來說：

- 免費的最香
- 提升網路安全性，擋下惡意網站訊息、不隨意導向至其他頁面（廣告商提供的頁面）

  ex: 許多主要 DNS 提供商處理查詢時實施域名劫持，導致瀏覽器進入未註冊域名時重新導向到廣告提供商的頁面，此舉明顯破壞了 DNS 規範，像中國電信在此情況下一般直接彈出充滿廣告的 114 頁面，相比之下，Google 承諾並不會如此作為

- 提供的 cache 較大，查詢 IP 的時候會比較快，也透過 cache 直接取得查詢結果，不必等候伺服器回應

## 什麼是資料庫的 lock？為什麼我們需要 lock？

先簡單舉個例，假設熱賣寫真「小松菜奈的秘密」在網路商店限量開賣了，大家瘋狂搶購。

結果賣到剩最後一本，在沒有設置 lock 的情況下，我跟小明同時發送了 request 也同時抵達 server，那就會一起處理，如果只是讀取的話，沒什麼差異，但今天這種狀況，同時處理交易（transaction），就會變成超賣，可能網路上告訴我我買到了，但我其實沒有買到，因為庫存只剩一本，不可能給兩個人，那這樣我就會吃不下飯睡不著，很難過的虛度光陰，同時詛咒小明。

這種情況就叫做 race condition(競爭危害)，就是同時讀取和寫入同一筆資料時產生的資料衝突。

為了避免我跟小明悲劇的發生，我們就需要「資料庫的交易資料鎖定」，就是 lock。

為了交易的並行性與獨立性，需透過做「記號」來標記該資料狀態正在被讀取或寫入，其他交易則根據該記號決定能否執行其他操作，而這個記號就是所謂的 lock（交易鎖定）。

```PHP
$conn->autocommit(FALSE);
$conn->begin_transaction();
$conn->query("SELECT amount from products where id = 1 for update");
// 加上 for update: 更新後就會把這行鎖起來，沒有指定欄位的話會鎖住整個 table
$conn->commit();
```

但由於鎖定後會需要等待執行，也須考慮到效能上的損耗，有些購物網站當掉的原因有可能就是 lock 太多資料，伺服器過載，無法執行下去

## NoSQL 跟 SQL 的差別在哪裡？

先簡單說明 NoSQL(Not Only SQL)意思

非關連式資料庫（ex, mongoDB），相對於關連式資料庫（之前使用過的 MySQL），他有以下幾點特性

- 不需要固定的結構(schema-free)，可以想像成存 JSON 資料進 Database
- 通常不使用關聯模型，但有需要時， NoSQL 也可以使用關聯模型與 schema
- 儲存方式：主要使用 key-value 來儲存資料
- 資料可任意切割，彈性較大
- 不支援 JOIN 語法
- 可用來儲存較大量且結構不固定的資料，例如：存取 log, 社交網站的大量資訊（按讚數, 分享等）

接著是 SQL(Structured Query Language)

結構化查詢語言，專門用來管理與查詢「關連式資料庫」(RDBMS) 的程式語言

關聯式資料庫(RDBMS)

- Relational Database Management System
- 以 SQL 語言操作
- 儲存方式：使用不同 table 存取不同類型的資料
- 資料之間保有相關性，也避免不相關的資料互相干擾
- 常見資料庫： MySQL, PostgreSQL
- 使用簡單、穩定且社群支援度高，使用較廣泛
- 上線後，資料庫的 Schema 就很難調整；且一旦資料量大時，設計和變更 Schema 較為困難
- ex: 會員資料庫，其中以會員 ID 作為明確關聯

## 資料庫的 ACID 是什麼？

#### 先來講講什麼是「transaction」？

中文可翻作交易，可視為資料庫執行過程的一個「邏輯單位」，一個 transaction 中包含多個對資料庫操作的行為，每個 transaction 有兩種可能的結局，**全部**執行成功或**全部**不執行（只要其中一個行為失敗就全部 rollback (回滾)，就是回到執行交易前的狀態）

- 一個 transaction = 一組一連串對資料庫進行存取、讀取、等的行為
- 全部 SQL 執行成功 -> commit
- 任一個 SQL 失敗 -> rollback

簡單說 transaction 存在有兩個目的：

1. 回到過去：當 transaction 過程中，有至少一個操作失敗時，整個 transaction 就會回滾（rollback）回到進行 transaction 「之前」的狀態

2. 維持獨立作業性：為了保持上述資料庫的一致性，因而讓不同 transaction 可以獨立不互相受干擾

ex, 假設我要從我自己的玉山銀行帳戶轉帳 1000 元到同樣是我自己的中信銀帳戶，會有兩個步驟：1. 玉山銀帳戶扣款 1000 元 2. 中信銀收到款項，多 1000 元。

假設今天第一步成功，第二步失敗

(X) 玉山銀少 1000 元，中信銀帳目不變，我又不是傻，讓自己總資產還默默變少
(O) 玉山銀少 1000 元，中信銀帳目沒增加時，整體 transaction 就會 rollback 到進行交易動作前的狀態

由此我們得知，要將以上的兩個步驟包在 transaction 當中，確保兩個步驟都成功才會完成，要是其中一個步驟失敗就會退到交易開始前的狀態，來避免資料不一致的悲劇發生。

接著是 transaction 的四大特性，一般我們會拿每個特性的英文字母開頭簡稱為「ACID」

#### - Atomicity 原子性

把整個 transaction 視為一個原子，是一個不可分割的邏輯單位。

基本上不是 transaction 都成功，不然就是都失敗，零和原理，沒有成功或失敗一半這種情況。若有其中一個操作沒有完成，那就是都失敗，會回到初始狀態

#### - Consistency 一致性

transaction 前後保持一致性。

資料庫從一個有效狀態經過 transaction 後變成另一個有效狀態

- 為了符合有效狀態，輸入的所有資料必須都符合規則
- transaction 進行後，資料庫的完整性沒有被破壞
- 不會因為進行了任一個 transaction，也不論它成功與否，而導致資料庫的完整性有所改變

ex: A, B 總共有一百元，不關他們怎麼交易，總和一定還是一百

#### - Isolation 獨立（隔離）性

transaction 過程中，不能被其他 transaction 影響

因為 transaction 只有成功或失敗，沒有中間，同時也沒辦法預知最後結果會是如何，所以必須確保每個 transaction 在進行時是互不干擾的，

A transaction 跟 B transaction 同時進行時用的資料庫應該要長一樣，不會有 B transaction 抓到的資料是 A transaction 進行到一半的資料庫的這種情況發生

#### - Durability 永久性

一旦資料修改完成，就變成永續存在，就算系統發生故障就算系統發生故障也不應該毀損

轉帳成功就是成功，不因為你的網銀 App 當掉，剛剛轉好的帳就發生問題
